===============================================================

Peter Loos

C All In One

C eine Woche:

Feedback:

== Was sind meine Erwartungen
== Was bringe ich mit //

     Schon mal C begonnen // anderen Sprachen (Python) // ...

== Überblick über die gesamte Sprache
== Muss was Spezielles drin sein !?!

===============================================================

Unterlagen:

https://github.com/pelocpp

https://github.com/pelocpp/c_introduction

===============================================================

Ab Dienstag:

Felder (Arrays)

Stack

Zeichen und Zeichenketten

=====================================================

C++, Java, C#, Python, JavaScript ....

===============================================================

GitHub

===============================================================


Allgemeines:

9 bis 17 Uhr

12.30 - 13.30

Übungen 

Mittwoch: Bis 15.30

===============================================================

IDE:  ===>  Visual C/C++ 

===============================================================

Zur IDE:

Visual Studio Community 2022

Versus

Visual Code

===============================================================

Hello World:

"Create a new Project"

"Empty Project"


Grundlegende Erstellung eines C-Prgramms:

C höhere Programiersprache:

Wörter:    Token  // Lexikon

Quelltext: ==> Grammatik  // Syntax

Semantik:  ==> Bedeutung des Programms // Tut das Programm das, was es soll.


Überprüfung der Syntax: Rechte Maustaste => Compile


=====================================

C ist eine format-freie Sprache

Leerzeichen // White-Spaces

=====================================

Phasen der Übersetzung:  // Übersetzungsarchitektur

Ziel der Übersetzung:

Java / C# ==> Zwischencode (Java: Byte-Code)

Zweite Übersetzung: Zwischencode  => Maschinencode

----------------------------------------------------

C/C++:

A) Syntax: ==> Compile

   Wenn Compile erfolgreich:  .c  ==> .obj (Standardisiertes Format)

   Welches Tool überprüft die Syntax: der COMPILER (Übersetzer)

B) Maschinencode: ==> Build:  .obj ==> .exe (Windows, Maschinencode)

   Welches Tool baut aus (mehreren) .obj-Dateien die Maschinencodedatei:

   LINKER

==========================================================

unresolved external symbol main referenced

in function "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ)

==========================================================

Quelltext ==> Compiler (.obj) ==> (.obj) Linker ===> (.exe) Maschinencode.

==========================================================

Vorgriff:  Unterprogramms

==========================================================

Vorsicht:

C: no bool , no string

====================================

Ablage der Zahl 123 im Speicher ???

Wie steht der Wert im Speicher ???

In Binär.

Binäre Darstellung: Zweier-Komplement.

Microcomputertechnik ==> Zahlensysteme.

C Datentypen:

int, long, short, long long:      Ganzzahlige Datentypen !

   Wieso mehrere ...  Unterschiedliche Wertebereiche.

   a) Wie wird er interpretiert: ganze Zahl
   b) Wie groß können seine Werte sein (Anzahl der Bytes / Bits im Speicher )

   Byte: (?? Welcher C-Datentyp):  -128 .. +127

   2 Bytes: Word C-Datentyp:  short

   -32.768 ... +32.767

Bemerkung:

short ==> -32.768 ... +32.767   // 16 Bits

Man könnte auch sagen:

Ich will den Wertebereich 0 .. 65.535 mit 16 Bits haben:

===> Das oberste Bit soll NICHT als Vorzeichen interpretiert werden.

Datentyp:  

unsigned short ==> 0 .. 65.535 
signed short   ==> -32.768 ... +32.767


Die Anzahl der Bytes kann man bestimmen:  sizeof

--------------------------------------------------------

float, double:

Was ist ein float-Wert:  Ein Komma-Wert

Da kann es zu Ungenauigkeiten kommen.

Das interne Format:  IEEE

https://www.h-schmidt.net/FloatConverter/IEEE754.html


Zu den Konstanten:  123.456

i)   123.456                ===> (Lexikon): double

ii)  123.456f oder 123.456F ===> (Lexikon): float




====================================================

Wert in binäre Darstellung.

123.456

char

Zeichenkette (string)

Pointer / Adresse

Struktur // struct
Union // union

================================================

Ein C-Projekt // mehrere Dateien.

Beobachtung:

printf wird aufgerufen - es fehlt das entsprechende Include:

Warning:
'printf' undefined; assuming extern returning int

Das ist eigentlich ein Fehler !!!!!!!!!!

Man sollte - in C - Warnings tunlichst vermeiden !!!!

Es fehlt

#include <stdio.h>

Standard Input Output

Noch eine Warnung:

1>Datatypes_Variabes.c(19,15): warning C4305: 'initializing':

  truncation from 'double' to 'float'


'variables_datatypes' undefined; assuming extern returning int

Wie kann man das vermeiden ???

Wie kann man ein Unterprogramm in einer anderen Datei aufrufen ????

extern-Deklaration.

============================================================

Kontroll-Strukturen:

if - Anweisung  / if - Statement

SYNTAX:

if ( bedingung ) 
{
     // ein oder mehrere Anweisungen
}


Was ist eine Bedingung ???

In vielen anderen Sprachen: bool-Wert:  true / false

C:

Eine Bedingung wird auf einen ganzzahligen Wert zurückgeführt:

a) Wert == 0:       Bedingung ist NICHT erfüllt

b) Wert ungleich 0: Bedingung ist erfüllt

Beispiel:

    int m = ....;

    if (m)  // geht, ungleich 0 wird abgefragt ....
    {
        printf("Bedingung erfuellt\n");
    }

    Besser:

    if (m != 0)  // geht,besser lesbar !!!
    {
        printf("Bedingung erfuellt\n");
    }

================================================

Bedingungen LOGISCH miteinander verknüpfen.

============================================================

Kontroll-Strukturen:

while - Anweisung  / while - Statement

Wiederholungsanweisung:

SYNTAX: 

while ( bedingung )
{
    // ein oder mehrere Anweisungen
}

============================================================

Debugger:   Tool

Führt ein Programm kontrolliert aus // Anweisung für Anweisung.

==> TESTEN  / Verifizieren: tut das Programm das, was wir erwarten (Semantik)

4 magische Tasten:

F9:  Haltepunkt
F5:  Go // Laufe ... bis zum nächsten Haltepunkt

F10: Einzelschritt // eine Anweisung // alles, was in EINER Zeile steht.
     Unterprogramm werden NICHT betreten.

F11: Einzelschritt // ein Unterprogramm wird betreten

===============================================================

void control_structures_while_01()
{
    int n = 1;

    while ( n < 5 )
    {
        n = n + 1;
    }

    printf("Done\n");
}

In Maschinencode:  MOV, CMP (Compare), JGE (Jump  Greater Equal), INC (increment)
                   LEA (Load Effective Address)


                   eax:  Akku // Akkumulator  // Zentrale Rechenregister

    int n = 1;
00007FF791B3422C  mov         dword ptr [n],1  

    while ( n < 5 )
00007FF791B34233  cmp         dword ptr [n],5  
00007FF791B34237  jge         control_structures_while_01+33h (07FF791B34243h)  
    {
       // printf("n: %d\n", n);

        n = n + 1;
00007FF791B34239  mov         eax,dword ptr [n]  
00007FF791B3423C  inc         eax  
00007FF791B3423E  mov         dword ptr [n],eax  
    }
00007FF791B34241  jmp         control_structures_while_01+23h (07FF791B34233h)  

    printf("Done\n");
00007FF791B34243  lea         rcx,[string "Done\n" (07FF791B3ACA0h)]  
00007FF791B3424A  call        printf (07FF791B3119Fh)  
00007FF791B3424F  nop  
}

===============================================================

Dennis Ritchie:

C sollte kompakt sein.

So kurz wie möglich  // C war nicht als Sprache zum Lernen konzipiert.

Kompaktheit: Ist manchmal mit Nebenwirkungen verbunden: VORSICHT !!!

    if (n < m && x < y++) {
        printf("bin hier\n");
    }

Man "sieht" hier ein y++ :


VORSICHT: Dieses muss nicht ausgeführt werden ????????

Wieso ???

Logisches UND: Ist die erste Bedingung NICHT erfüllt,
so wird die zweite Bedingung überhaupt nicht AUSGEFÜHRT !!!!

Short - Circuit Evaluation:

Abbruch der gesamten Auswertung einer Bedingung,
wenn deren vorzeitiges Ergebnis "früher" feststeht.

Wieso sind derartige Optionen in C enthalten:

Dennis Ritchie: "A programmer knows what he does"  :)

==> Vieles, was eigentlich ein Fehler ist, wird in C als Warning gemeldet.


===============================================================

1. Aufgabe:  Teuflische Folge.

Collatz Folge

Zahlenfolge:

Startwert n;

Nächster Wert:

n => n / 2;        // n gerade

n => 3 * n + 1;    // n ungerade

Startwert 7:

7 => 22 => 11 => 34 => 17 => 52 => 26 => 13 => 40 => 20 => 10 => 5 => 16 => 8 => 4 => 2 => 1: Ende !

Diese Folge ist endlich:

JEDE dieser Folgen ist endlich:  Kann man bis heute mathematisch nicht beweisen !?!?!?!?!

==========================

https://github.com/pelocpp/c_introduction/blob/master/C_Introduction/Exercises/Exercises.md

==========================

Zeiger
------

Sind im Zentrum von C.

Reihe von Datentypen: Wert.

Auch Datentypen:  Adressen im Speicher darstellen.

Welche Adressen:

i) Variablen

ii) Daten dynamisch allokieren.

Zur Vereinbarung: 

Adresse:  Speicher

In C sieht man hinter einer Adresse einen Wert:
Damit verknüpft man in C eine Adresse mit einem Datentyp:
Der Datentyp des Werts, der sich hinter einer bestimmten
Adresse verbirgt.



a) Adress-Operator:  &

Beispiel: ip	0x0000005e492ff7a4 {123}	int *

0x 00 00 00 5e 49 2f f7 a4

a4 2f7 f 49 5e 00 00 00

+		ip	0x00000074233ef864 {123}	int *

Adresse: 8 Bytes

=================================================

Wozu hat man Adressen in C  ??? Why ????

=================================================

Unterprogrammen:

A) Allgemein: Um mehrere Anweisungen // Folge von Anweisungen
   unter einem Namen anzuordnen.

   Die Folge der Anweisungen wird durch den Namen aufgerufen.

B) In C unterscheidet man:

  i)  Unterprogramme, die KEIN Ergebnis zurückliefern:

      Der Rückgabetyp ist void in diesem Fall.

        Wording: Subroutine // Unterprogramm

  ii) Unterprogramme, die EIN Ergebnis zurückliefern

  Dann muss es einen Rückgabetyp ungleich void geben.

  Wording: Funktion // Function.
   



Vorsicht:

'ausgabe': 'void' function returning a value

DAS IST EIN FEHLER.

warning C4716: 'product': must return a value.

Parameter eines Unterprogramms: Stellvertreter für reale Werte.

==========================================================

Parameterübergabe:

Call-by-Value:    Aufruf-mit-Wert

Call-by-Address:  Aufruf-mit-Adresse

Siehe auch

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/ParameterPassingTechniques.md


Wozu Adressen:

== Ermöglichen Zugriff auf das Original // nicht auf eine Kopie !!!

== Manchmal: Schutz des Originals:  Dann kann eine Kopie von Vorteil sein !!!





Vorsicht:

warning C4047: 'function':

'int *' differs in levels of indirection from 'int'

DAS IST EIN FEHLER !!!!!!!!!!!!!!!!!!!!!!!!!!

====================================================

Was ist der Call-Stack  // Aufruf-Stapel ???

Eine Abbildung // Darstellung aller Variablen des AKTUELLEN Unterprogramms.

=======================================================

Release-Modus:

Keine Debug-Info enthalten  // Langsamer

==> Volle Optimierungsstufe.

=======================================================

for, while und do-while:  break und continue;

Bemerkung:

Ein while und for können "gar-nicht" bzgl. des Rumpfs ausgeführt werden.

Der Rumpf einer do-while Anweisung wird "mindestens" EINMAL ausgeführt.

Beobachtung:  Ein while sieht man "im echten Leben" häufiger.  

=======================================================

switch:

Wozu break ????????????

Hmmm, Dennis Ritchie hat eigentlich mehr die Sichtweise des Maschinencodes
 vor Augen gehabt:  ===> Sprungbefehl:  jmp

======================================================

Aufgabe:

x: 5, y: 6
x: 6, y: 5

=====================================================

Zeigerarithmetik

=====================================================

Feedback:  Zu langsam, Zu Schnell, Paschd scho.


=====================================================

Nachträge zu den Operatoren:

== Vorrang // Präzedenz

== Assoziativität

== Stelligkeit

unäre Operatoren: Operatoren mit EINEM Operanden:

   ++ x;

   - x;

   + x;

binäre Operatoren: Operatoren mit ZWEI Operanden:

   a + b;    + Operator hat ZWEI Operanden
   
ternäre Operatoren: Operatoren mit DREI Operanden:

  ?:

  SYNTAX:

  bedingung ? expression1 : expression2 ;

  Wert des Ausdrucks: Entweder der Wert von expression1 oder expression2,
  je nach dem Wert der 'bedingung':
  true => expression1
  false => expression2

  Beispiel:

      x = (a > b) ? 10 : 20;

      if (a > b) {
          x = 10;
      }
      else {
          x = 20;
      }


    ODER:  
    
    return (a > b) ? 10 : 20;

============================================

Feld // Array

Vergleich:

C# / Java:     int[] zahlen = new 

C:
 
 Ein Feld hat eine FESTE GRÖSSE !!!!!!! Durch einen KONSTANTEN Wert festgelegt werden.

 Bemerkung:

 Für Variablen, die NICHT vorbelegt sind,
 wird ein spezielles Muster in den Speicher geschrieben:
 0xCC == Visual C++

 Vorsicht !!!!!!!!!!!!!!!!!

Falsche Indices für Felder in C werden NICHT zur Laufzeit
überprüft !!!!!!!!!!!!!!!

Wie läuft das Programm dann ab:

UB:  Undefined Behaviour

== Es läuft - wir erkennen keine Fehler 
== Es stürzt ab
== Sporadische Feher / Abstürze

In C#/ Java wird ein Programm im Kontext einer virtuellen Maschine ausgeführt.
(JVM, CLR) ==> Hier werden Indices kontrolliert ==> Abbruch 
Kontrolliert // Exception // könnte man fangen (try .. catch)

============================================================

Es gibt Anweisungen der Gestalt

#define Max 5

Die ist eine Preprocessor-Anweisung (Präprozessor):

Was ist der Präprozessor:

Tool, welches eine Textersetzung / Textaustausch vornimmt:

Jedes Vorkommen von Max ==> 5

Ausnahmen:  "Maximum"

Auch 

#include <stdio.h>

ist eine Präprozessor-Anweisung.

Hinweis: 

Der Gebrauch des Präprozessor ist nicht unbedingt Best-Practice:

#define Max 5

Hier laufern Gefahren !!!!!!!!!!!!!!!!!!!!!!!!!!!


==========================================================

Quelltext 
   ==> Präprozessor 
   ==> Compiler (.obj) 
   ==> (.obj) Linker 
   ==> (.exe) Maschinencode.

==========================================================

Zusammenfassung:

Felder in C:

Fixed-Size !!!

Keine Überprüfung des Index zur Laufzeit !!!

Längenangabe: 

Kann mit #define erfolgen:  // Präprozessor-Anweisung.

Vorsicht bei  Präprozessor-Anweisungen: 

Die Textersetzung wird "wörtlich" genommen.

==========================================================

Struktur eines C-Programms:

== Ein oder mehrere C-Dateien.  // Endung .c

== Ein oder mehrere Header-Dateien.  // Endung .h

   Für zB globale Funktionen

== Es gibt auch Funktionen, die in anderen Dateien NICHT verfügbar sein sollen
   -- Hilfsfunktionen
   -- Keyword 'static'

==========================================================

Datentyp char // Zeichen:

Syntax:  Einzelhochkomma für Zeichen !

Ausnahmen:  '\n' (13)  '\r'   (10)


Ein char steht für EIN einzelnes Zeichen!

Wie wird ein Zeichen im Speicher abgelegt ?

Binäre Darstellung eines Zeichens ???

ASCII-Tabelle:  

Abbildung von Zeichen auf numerische Werte.

Bebachtung:

Dualität zwischen char und int.

=================================================

Beobachtung:

Wie ist \n definiert.

Unter Windows sind das 2 Zeichen:

0D  0A  // 13 10

Linux uses a single LineFeed character:

'\n'  0x0A  10

History:

So in ASCII, we really still only have Carriage Return \r which is 0x0d (Decimal 13),
and Line Feed \n, which is 0x0a (Decimal 10).


=============================================================

Zeichenketten:

Syntax:  Doppelhochkomma für Zeichenketten !

"12345"

Binäre Darstellung:

Gemäß den ASCII - Werten:

49 50 51 52 53 0

Problem: Wo steht die Länge einer Zeichenkette ???

a) Nirgends !!!
b) Die terminierende Null

Kleine Fragen:

Wie lang ist die Zeichenkette "12345" ???

i) 5

ii) Gegenfrage: Allgemein oder bzgl. der Ablage im Speicher.

    Ablage im Speicher:  6 Zeichen !!!!

Zweite Frage:

Von welchem Datentyp ist eine Zeichenkette in C ???

"12345"

a) const char* cp;    

b) Feld von Zeichen: char []

Dualität zwischen Feldern des Typs char und Zeichenketten.

======================================================

Zwischen Arrays und Pointern in C gibt es einen DIREKTEN Zusammenhang:

int numbers[10];

Der Bezeichner 'numbers' steht für die ANFANGSADRESSE des Arrays im Speicher.

======================================================

Nebenbei:

C ist in C++ "echt" enthalten - zu 99%.

Ein Beispiel: char* cp = "234"; geht NICHT in C++

Wahrheit: Auch nicht in C - Absturz.

Frage: Wo liegt eine Zeichenkette wir "123" im Speicher ??????????????

Speicherbereiche:

Datenspeicher 

Konkreter: Es kann das Code-Segment sein. Speicher für den Maschinencode.

Historische Gründe

========================================================

Fazit:

Konstante Zeichenkette ("123") sind NICHT schreibbar !!!

Sie liegen in einem schreibgeschützten Datenbereich.

Abhilfe:

Eine Zeichenkette in einen schreibbaren Bereich legen:

ALLES außer einer konstante Zeichenkette :)

ZB ein Feld von Zeichen.

======================================================

Zwischen Arrays und Pointern in C gibt es einen DIREKTEN Zusammenhang:

int numbers[10];

Der Bezeichner 'numbers' steht für die ANFANGSADRESSE des Arrays im Speicher.

Wo spielt das eine Rolle:

Bei der Übergabe eines Felds an ein Unterprogramm.
--------------------------------------------------

Folgefrage:

Wieviele Elemente sind hinter einer Adresse (Anfangsadresse) vorhanden ???

===> Das weiß man nicht !!!

Konsequenz:

Wie wird ein Feld an ein Unterprogramm übergeben ??????

Antwort: Mit Anfangsadresse UND Längenangabe.

Ausnahme: Zeichenketten:

Da geht es ohne die Längenangabe, weil am Ende der Zeichenkette im Speicher
ein 0-Wert steht.


Achtung:

'printf' : format string '%s' requires an argument of type 'char *',
but variadic argument 1 has type 'int *'


=============================================================

Zeiger-Arithmetik:
-------------------

Man kann mit Zeigern - in einem gewissen Umfang - rechnen !!!

Beispiel:

int* feld;
int  i;

feld + i

Was ist feld + i für eine Adresse ??????????

Beispiel: 

In feld steht 0x1024 drin.

Was ist feld + 1 für eine Adresse ???

1. Vermutung: 0x1025 

ABER: Ein int belegt im Speicher 4 Bytes !!!!!

Deshalb bedeutet feld + 1, wenn feld eine int-Adresse ist,
einen neuen Wert von +4:

 0x1024 ==> 0x1028

 Realität: Der Index (also zB 1) wird mit der Anzahl Bytes eines int-Werts
           multipliziert-

===============================================

Zeiger-Arithmetik:
-------------------

2 Optionen:

Adresse + Offset

++ Adresse          ; 0x1024 ==> 0x1028, wenn die Adresse auf einen int-Wert zeigt

===============================================

Ein Vergleich:

        tmp = *(feld + i);   // Zeiger Arithmetik
00007FF69528352E  movsxd      rax,dword ptr [rbp+24h]  
00007FF695283532  mov         rcx,qword ptr [feld]  
00007FF695283539  mov         eax,dword ptr [rcx+rax*4]  
00007FF69528353C  mov         dword ptr [rbp+44h],eax  

        tmp = feld[i];         // mit Index-Notation 
00007FF69528353F  movsxd      rax,dword ptr [rbp+24h]  
00007FF695283543  mov         rcx,qword ptr [feld]  
00007FF69528354A  mov         eax,dword ptr [rcx+rax*4]  
00007FF69528354D  mov         dword ptr [rbp+44h],eax  

Ironische Bemerkung:

"C hat keine Arrays" - wegen der Zeiger-Arithmetik


===============================================

Zeichenkettenverarbeitung:
-------------------------

Benerkung:

warning C4716: 'str_length': must return a value

Aber wir erhalten nur eine Warnung :(((((


===============================================================

toUpper:

a) Wenn ch ist kein Buchstabe => in das Ergebnis übernehmen !!!  zB '?'

b) if (ch >= 'a' && ch <= 'z')

   Wie wird aus klein groß ???

   ch = ch - 32;


==============================================================

Übungen

static void str_toUpper (char* src);

static void str_reverse (char* src);

// Einfügen EINES Zeichen
int chr_insert  (const char* src, int pos, char ch, char* dest, int destLen);

// Einfügen EINER Zeichenkette
int  str_insert  (const char* src, int pos, char* toInsert, char* dest, int destLen);

==============================================================

Speicherbereiche eines C–Programms:

(( Kleine Unterschiede zu Java / C# ))

a) Globale Variablen.

i) Definition

In EINER Datei:

int g_globalValue = 123;

ii) Verwendung:

Setzt eine Bekanntmachung voraus:

extern int g_globalValue;

Lebensdauer: Für die gesamte Laufzeit eines Programms !!!

Bemerkung:

Man kann die Verfügbarkeit einer globalen Variablen einschränken:

a) nur in einer Datei 

b) nur in einem Unterprogramm  // Gegenstück zur Charakteristik einer lokalen Variablen

Moral:

"Scattering" von globalen Variablen zu vermeiden

Benutze static so viel wie möglich .....

----------------------------------------------------------

a) Lokale Variablen:

Vereinbarung:

In Funkionen // NUR in Funktionen:

Exakter:  In Blöcken


===========================================================

Bebachtung:

Ein Header-File ist nicht übersetzbar ?!?

Struktur eines C-Projekts halten:

Viele C Files ====> 

Pro C-File resutiert EIN .obj File

Header-Files enthalten Informationen, zB extern-Deklarationen,
aber zu einem Header-File wird KEIN .obj File erzeugt.


Frage:

void test_using_local_variabes()
{
    int n = 123;  // lebt bis zum Ende der Funktion
    printf("n: %d\n", n);

    {
        int m = 456;  // lebt bis zum Ende des  Blocks  // { }
        printf("m: %d\n",m);

        int n = 789; 
        printf("n: %d\n", n);
    }

}

Ist in C# nicht übersetzungsfähig !

In C ist das übersetzungsfähig !!!

Stilistisch fragwürdig !!!

Don't go for this feature.

================================================

Speicherbereiche:
----------------

i)   Global ==> Datensegment
ii)  Lokal ==> Stack
iii) Dynamisch ==> Heap  // Halde (kommt noch)

Strukturen

Dynamische Speicherverwaltung

================================================

Lokale Variablen:

Stehen in einem Unterprogramm (Block) zur Verfügung
Nach dem Verlassen des Unterprogramms sind sie weg.

Frage: Wie kann man so etwas datentechnisch realisieren ???

Antwort: Stapel // Stack 


Unterprogramm:

  int a; 
  int b;

  ==> 2. Unterprogramm:

      int x;
      int y;
      int z;

  <===

  a = 3;
  b = 4;

Bereich: "Stack" // Stack-Segment // Stapel

Register: Stack-Pointer

Unterprogramm-Aufrufs // Stack 

===> "Stack-Frame"

Die "Stack-Frame"s eines laufenden Programms werden im Fenster "Call Stack" visualisiert.

==========================================================

Intel CPU:

Klassisch: 4 zentrale Segmente 

Aktuell:   6 Segmente

Segment-Register 

===========================================================

Strukturen

// Java, C#:  Der Vorgänger von Klassen

Was ist eine Struktur?

Eine Zusammenfassung von mehreren Variablen (auch unterschiedlichen Datentyps)
in einem gemeinsamen Sprachkonstrukt:

Beispiel:

Uhrzeit:  Stunden, Minuten und Sekunden

9:54:30 

int hours;
int minutes;
int seconds;

int hours1;
int minutes1;
int seconds1;

SYNTAX:

struct Name 
{
};


Alignment: Was ist das ???

Eine Festlegung, wo (elementare) Variablen im Speicher liegen 
in Bezug auf die Speicheradresse!

Beispiel:

int n;    // 0x1024

Frage: Könnte n auch an der Adresse 0x1025 liegen ?????

Prinzipiell ja:

Praxis:
Auf eine Variable // Speicherbereich mit mehreren Bytes
(int: 4 Bytes) wird über den Datenbus eine Adresse geschoben.

Eine CPU möchte diesen Zugriff PERFORMANT gestalten:
Damit das PERFORMANT geht, können / müssen in manchen Situationen
die Adressen VIELFACHE der GRÖSSE der Variablen sein.

Konkret:

Eine Variable wie n (int) kann liegen an

0x1024: Ja
0x1025: Nein
0x1026: Nein
0x1027: Nein
0x1028: Ja


Aber:

char vieleZeichen[4];

Hier liegen die Array-Variablen DICHT im Speicher.


Weitere Frage:

Welches Alignment hat eine Struktur:

Den Wert des größten Alignments in Bezug auf alle enthaltenen Variablen.


=================================================================

Strukturen an Funktionen übergeben:

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/ParameterPassingTechniques.md


Voreinstellung: Call-by-Value    ==> KOPIE

Benötigen:      Call-by-Address  ==> Adresse (==> Original)

==================================================================

static void printTime(Time time)
{
    printf("%02d:%02d:%02d\n", time.hours, time.minutes, time.seconds);
}

Hat so funktioniert :)

Belassen wir printTime so oder wechseln wir auch hier zur Übergabe einer Adresse ???

Wir sollten auch hier zu einer Adresse wechseln!

Was ist das Problem mit Kopien von Strukturvariablen ??? ==> Laufzeit , Performanz:

Beobachtung:

Strukturvariablen, die von einem UNTERPROGRAMM NICHT geändert werden sollten,
können bei Übergabe einer Adresse geändert werden.

Abhilfe:

Keyword const

=================================================================

Exkurs:

Objekt-Orientierung:

"Objekt-Orientierung in C für Arme". 

Wie könnte das aussehen:

== Beschreibung der Daten:

In einer Struktur (C++/C#/Java: Klasse)

== Beschreibung der Methoden:

C: Durch Funktionen, die die Struktur als ersten Parameter haben.

In C++/C#/Java:
Innerhalb der Klasse

== Vorbelegung von Strukturvariablen (C++/C#/Java: Objekt)

C: Mit einer Vorbelegungslistem
   zB

   Time now = { 10, 55, 0 };

C++/C#/Java: Konstruktoren

   Time now = new Time { 10, 55, 0 };   // C#/Java

== Destruktoren:

   Kommt noch.

====================================================

C kennt keinen Datentyp bool:

Konvention:

Man nehme int an Stelle von bool.

false: 0
true: ungleich 0

====================================================

Ein bool Ersatz für C

#include <stdbool.h>

====================================================

Übung Wallet:

Ein Tipp:

Ist mit 2 Variablen manchmal etwas lästig ...

Tipp:

Man nehme EINE Variable:  Da ist die Realisierung einfacher ....

unsigned int cents;

// Permanent von (Euro, Cent) ==> Cents runtergerechnet werden.

struct wallet
{
    unsigned long long m_euros;
    unsigned int       m_cents;
};

versus

// Lernen etwas dünne
struct wallet
{
    unsigned int m_cents;
};

========================================================

Bitweise Operationen bekannt / nicht bekannt

Ein Bit in einem int-Wert setzen / löschen

=======================================================

Ein Vergleich:

    struct Status1 status1;
    status1.heightValidated = 1;
00007FF68A516A3E  mov         dword ptr [rbp+0Ch],1     // BP = Base Pointer

    struct Status2 status2;
    status2.heightValidated = 1;
00007FF68A516A45  mov         eax,dword ptr [status2]  
00007FF68A516A48  or          eax,2  
00007FF68A516A4B  mov         dword ptr [status2],eax  

C und Bitfelder:

Pro:    Ermöglichen eine sehr KOMPAKTE Ablage von komprimierten Informationen (auf der Ebene von Bits)

Contra: Der resultierende Maschinencode ist aufwendiger)

Krux:   Performance versus Speicherbedarf.

=======================================================

Union:

Sehr ähnlich zu einer Struktur, ABER !!!!!!!!!!!!!!!

Alle Variablen der Union liegen
im Speicher ÜBEREINANDER / an derselben Stelle.

Why ?????????????????????????????????????????

Beispiel wie RGB oder eine IP-Adresse veranschaulicht ....

===================================================== 

Enum:   ==> Pascal

==> Bessere Lesbarkeit

Go for Enum.

====================================================

Low-Level Programmierung
========================

Spezielle Operatoren für Bit-weise Verarbeitung.

& (Binäres Und)  , | (Binäres Oder)  , Exklusives Oder (^), Negation (~)

Schiebe-Operationen: << und >>

1. Beispiel:

              10110011
              11001101
Binäres UND:  10000001


2. Beispiel:

               10110001
               11001101
Binäres ODER:  11111101


3. Beispiel:

                  1011 0001
                  1100 1101
Exklusiver ODER:  0111 1100   == 7C


====================================  

Schieben:

0010'0011

Nach links um 2 Bits schieben:

1000'1100 

Es werden unten 2 Nullen reingezogen.


VORSICHT:

2. Beispiel:

short:  16 Bits:

1000 1010 1100 0011

Nach rechts um 2 Bits schieben:

??10 0010 1011 0000

2 Antworten:

a) signed short (short) ==> Es werden von oben 1 nachgezogen,
            wenn aktuell das oberste Bit eine 1 ist (weil die Zahl negativ ist)

            Andernfalls 0-en.

b) unsigned short 

   Es werden 0 nachgezogen.

==============================================

Ein Bit setzen:

=============>
             |
value: 11010101010101
mask:  00000010000000
=====
OR     11010111010101

Wie erhalten wir diese Maske ???

0000000000100

Mit 1 << pos;

Ein Bit löschen:

================>
                |
value: 11010101010101
mask:  11111111101111
=====
AND    11010111010101

Hinleitung:

00000010000000  ==> invertieren:
11111101111111

Binäre Not: Aus 0 mach 1, aus 1 mach 0

======================================================

