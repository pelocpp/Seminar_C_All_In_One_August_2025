===============================================================

Peter Loos

peter.loos@gmx.de
-----------------

C All In One

C in einer Woche:

Feedback:

== Was sind meine Erwartungen
== Was bringe ich mit //

     Schon mal C begonnen // anderen Sprachen (Python) // ...

== Überblick über die gesamte Sprache
== Muss was Spezielles drin sein !?!

===============================================================

Unterlagen:

https://github.com/pelocpp

https://github.com/pelocpp/c_introduction

===============================================================

C++, Java, C#, Python, JavaScript ....

===============================================================

C:  Dennis Ritchie

Warum so selten Fehler, meist nur Warnings:

"A Programmer knows what he does" :)

===============================================================

Allgemeines:

9 bis 17 Uhr

12.30 - 13.30

Übungen 

Mittwoch: Bis 15.30

===============================================================

IDE:  ===>  Visual C/C++ 

===============================================================

Zur IDE:

Visual Studio Community 2022

Versus

Visual Code

===============================================================

Hello World:

"Create a new Project"

"Empty Project"


Grundlegende Erstellung eines C-Prgramms:

C höhere Programiersprache:

Wörter:    Token  // Lexikon

Quelltext: ==> Grammatik  // Syntax

Semantik:  ==> Bedeutung des Programms // Tut das Programm das, was es soll.


Überprüfung der Syntax: Rechte Maustaste => Compile


=====================================

C ist eine format-freie Sprache

Leerzeichen // White-Spaces

=====================================

Phasen der Übersetzung:  // Übersetzungsarchitektur

Ziel der Übersetzung:

Java / C# ==> Zwischencode (Java: Byte-Code)

Zweite Übersetzung: Zwischencode  => Maschinencode

----------------------------------------------------

C/C++:

A) Syntax: ==> Compile

   Wenn Compile erfolgreich:  .c  ==> .obj (Standardisiertes Format)

   Welches Tool überprüft die Syntax: der COMPILER (Übersetzer)

B) Maschinencode: ==> Build:  .obj ==> .exe (Windows, Maschinencode)

   Welches Tool baut aus (mehreren) .obj-Dateien die Maschinencodedatei:

   LINKER

==========================================================

unresolved external symbol main referenced

in function "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ)

==========================================================

Quelltext ==> Compiler (.obj) ==> (.obj) Linker ===> (.exe) Maschinencode.

==========================================================

Vorgriff:  Unterprogramms

==========================================================

Vorsicht:

C: no bool , no string

====================================

Ablage der Zahl 123 im Speicher ???

Wie steht der Wert im Speicher ???

In Binär.

Binäre Darstellung: Zweier-Komplement.

Microcomputertechnik ==> Zahlensysteme.

C Datentypen:

int, long, short, long long:      Ganzzahlige Datentypen !

   Wieso mehrere ...  Unterschiedliche Wertebereiche.

   a) Wie wird er interpretiert: ganze Zahl
   b) Wie groß können seine Werte sein (Anzahl der Bytes / Bits im Speicher )

   Byte: (?? Welcher C-Datentyp):  -128 .. +127

   2 Bytes: Word C-Datentyp:  short

   -32.768 ... +32.767

Bemerkung:

short ==> -32.768 ... +32.767   // 16 Bits

Man könnte auch sagen:

Ich will den Wertebereich 0 .. 65.535 mit 16 Bits haben:

===> Das oberste Bit soll NICHT als Vorzeichen interpretiert werden.

Datentyp:  

unsigned short ==> 0 .. 65.535 
signed short   ==> -32.768 ... +32.767


Die Anzahl der Bytes kann man bestimmen:  sizeof

--------------------------------------------------------

float, double:

Was ist ein float-Wert:  Ein Komma-Wert

Da kann es zu Ungenauigkeiten kommen.

Das interne Format:  IEEE

https://www.h-schmidt.net/FloatConverter/IEEE754.html


Zu den Konstanten:  123.456

i)   123.456                ===> (Lexikon): double

ii)  123.456f oder 123.456F ===> (Lexikon): float




====================================================

Wert in binäre Darstellung.

123.456

char

Zeichenkette (string)

Pointer / Adresse

Struktur // struct
Union // union

================================================

Ein C-Projekt // mehrere Dateien.

Beobachtung:

printf wird aufgerufen - es fehlt das entsprechende Include:

Warning:
'printf' undefined; assuming extern returning int

Das ist eigentlich ein Fehler !!!!!!!!!!

Man sollte - in C - Warnings tunlichst vermeiden !!!!

Es fehlt

#include <stdio.h>

Standard Input Output

Noch eine Warnung:

1>Datatypes_Variabes.c(19,15): warning C4305: 'initializing':

  truncation from 'double' to 'float'


'variables_datatypes' undefined; assuming extern returning int

Wie kann man das vermeiden ???

Wie kann man ein Unterprogramm in einer anderen Datei aufrufen ????

extern-Deklaration.

============================================================

Kontroll-Strukturen:

if - Anweisung  / if - Statement

SYNTAX:

if ( bedingung ) 
{
     // ein oder mehrere Anweisungen
}


Was ist eine Bedingung ???

In vielen anderen Sprachen: bool-Wert:  true / false

C:

Eine Bedingung wird auf einen ganzzahligen Wert zurückgeführt:

a) Wert == 0:       Bedingung ist NICHT erfüllt

b) Wert ungleich 0: Bedingung ist erfüllt

Beispiel:

    int m = ....;

    if (m)  // geht, ungleich 0 wird abgefragt ....
    {
        printf("Bedingung erfuellt\n");
    }

    Besser:

    if (m != 0)  // geht,besser lesbar !!!
    {
        printf("Bedingung erfuellt\n");
    }

================================================

Bedingungen LOGISCH miteinander verknüpfen.

============================================================

Kontroll-Strukturen:

while - Anweisung  / while - Statement

Wiederholungsanweisung:

SYNTAX: 

while ( bedingung )
{
    // ein oder mehrere Anweisungen
}

============================================================

Debugger:   Tool

Führt ein Programm kontrolliert aus // Anweisung für Anweisung.

==> TESTEN  / Verifizieren: tut das Programm das, was wir erwarten (Semantik)

4 magische Tasten:

F9:  Haltepunkt
F5:  Go // Laufe ... bis zum nächsten Haltepunkt

F10: Einzelschritt // eine Anweisung // alles, was in EINER Zeile steht.
     Unterprogramm werden NICHT betreten.

F11: Einzelschritt // ein Unterprogramm wird betreten

===============================================================

void control_structures_while_01()
{
    int n = 1;

    while ( n < 5 )
    {
        n = n + 1;
    }

    printf("Done\n");
}

In Maschinencode:  MOV, CMP (Compare), JGE (Jump  Greater Equal), INC (increment)
                   LEA (Load Effective Address)


                   eax:  Akku // Akkumulator  // Zentrale Rechenregister

    int n = 1;
00007FF791B3422C  mov         dword ptr [n],1  

    while ( n < 5 )
00007FF791B34233  cmp         dword ptr [n],5  
00007FF791B34237  jge         control_structures_while_01+33h (07FF791B34243h)  
    {
       // printf("n: %d\n", n);

        n = n + 1;
00007FF791B34239  mov         eax,dword ptr [n]  
00007FF791B3423C  inc         eax  
00007FF791B3423E  mov         dword ptr [n],eax  
    }
00007FF791B34241  jmp         control_structures_while_01+23h (07FF791B34233h)  

    printf("Done\n");
00007FF791B34243  lea         rcx,[string "Done\n" (07FF791B3ACA0h)]  
00007FF791B3424A  call        printf (07FF791B3119Fh)  
00007FF791B3424F  nop  
}

===============================================================

Dennis Ritchie:

C sollte kompakt sein.

So kurz wie möglich  // C war nicht als Sprache zum Lernen konzipiert.

Kompaktheit: Ist manchmal mit Nebenwirkungen verbunden: VORSICHT !!!

    if (n < m && x < y++) {
        printf("bin hier\n");
    }

Man "sieht" hier ein y++ :


VORSICHT: Dieses muss nicht ausgeführt werden ????????

Wieso ???

Logisches UND: Ist die erste Bedingung NICHT erfüllt,
so wird die zweite Bedingung überhaupt nicht AUSGEFÜHRT !!!!

Short - Circuit Evaluation:

Abbruch der gesamten Auswertung einer Bedingung,
wenn deren vorzeitiges Ergebnis "früher" feststeht.

Wieso sind derartige Optionen in C enthalten:

Dennis Ritchie: "A programmer knows what he does"  :)

==> Vieles, was eigentlich ein Fehler ist, wird in C als Warning gemeldet.


===============================================================

1. Aufgabe:  Teuflische Folge.

Collatz Folge

Zahlenfolge:

Startwert n;

Nächster Wert:

n => n / 2;        // n gerade

n => 3 * n + 1;    // n ungerade

Startwert 7:

7 => 22 => 11 => 34 => 17 => 52 => 26 => 13 => 40 => 20 => 10 => 5 => 16 => 8 => 4 => 2 => 1: Ende !

Diese Folge ist endlich:

JEDE dieser Folgen ist endlich:  Kann man bis heute mathematisch nicht beweisen !?!?!?!?!

==========================

https://github.com/pelocpp/c_introduction/blob/master/C_Introduction/Exercises/Exercises.md

==========================

Zeiger
------

Sind im Zentrum von C.

Reihe von Datentypen: Wert.

Auch Datentypen:  Adressen im Speicher darstellen.

Welche Adressen:

i) Variablen

ii) Daten dynamisch allokieren.

Zur Vereinbarung: 

Adresse:  Speicher

In C sieht man hinter einer Adresse einen Wert:
Damit verknüpft man in C eine Adresse mit einem Datentyp:
Der Datentyp des Werts, der sich hinter einer bestimmten
Adresse verbirgt.



a) Adress-Operator:  &

Beispiel: ip	0x0000005e492ff7a4 {123}	int *

0x 00 00 00 5e 49 2f f7 a4

a4 2f7 f 49 5e 00 00 00

+		ip	0x00000074233ef864 {123}	int *

Adresse: 8 Bytes

=================================================

Wozu hat man Adressen in C  ??? Why ????

=================================================

Unterprogrammen:

A) Allgemein: Um mehrere Anweisungen // Folge von Anweisungen
   unter einem Namen anzuordnen.

   Die Folge der Anweisungen wird durch den Namen aufgerufen.

B) In C unterscheidet man:

  i)  Unterprogramme, die KEIN Ergebnis zurückliefern:

      Der Rückgabetyp ist void in diesem Fall.

        Wording: Subroutine // Unterprogramm

  ii) Unterprogramme, die EIN Ergebnis zurückliefern

  Dann muss es einen Rückgabetyp ungleich void geben.

  Wording: Funktion // Function.
   



Vorsicht:

'ausgabe': 'void' function returning a value

DAS IST EIN FEHLER.

warning C4716: 'product': must return a value.

Parameter eines Unterprogramms: Stellvertreter für reale Werte.

==========================================================

Parameterübergabe:

Call-by-Value:    Aufruf-mit-Wert

Call-by-Address:  Aufruf-mit-Adresse

Siehe auch

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/ParameterPassingTechniques.md


Wozu Adressen:

== Ermöglichen Zugriff auf das Original // nicht auf eine Kopie !!!

== Manchmal: Schutz des Originals:  Dann kann eine Kopie von Vorteil sein !!!





Vorsicht:

warning C4047: 'function':

'int *' differs in levels of indirection from 'int'

DAS IST EIN FEHLER !!!!!!!!!!!!!!!!!!!!!!!!!!

====================================================

Was ist der Call-Stack  // Aufruf-Stapel ???

Eine Abbildung // Darstellung aller Variablen des AKTUELLEN Unterprogramms.

=======================================================

Release-Modus:

Keine Debug-Info enthalten  // Langsamer

==> Volle Optimierungsstufe.

=======================================================

for, while und do-while:  break und continue;

Bemerkung:

Ein while und for können "gar-nicht" bzgl. des Rumpfs ausgeführt werden.

Der Rumpf einer do-while Anweisung wird "mindestens" EINMAL ausgeführt.

Beobachtung:  Ein while sieht man "im echten Leben" häufiger.  

=======================================================

switch:

Wozu break ????????????

Hmmm, Dennis Ritchie hat eigentlich mehr die Sichtweise des Maschinencodes
 vor Augen gehabt:  ===> Sprungbefehl:  jmp

======================================================

Aufgabe:

x: 5, y: 6
x: 6, y: 5

=====================================================

Zeigerarithmetik

=====================================================

Feedback:  Zu langsam, Zu Schnell, Paschd scho.


=====================================================

Nachträge zu den Operatoren:

== Vorrang // Präzedenz

== Assoziativität

== Stelligkeit

unäre Operatoren: Operatoren mit EINEM Operanden:

   ++ x;

   - x;

   + x;

binäre Operatoren: Operatoren mit ZWEI Operanden:

   a + b;    + Operator hat ZWEI Operanden
   
ternäre Operatoren: Operatoren mit DREI Operanden:

  ?:

  SYNTAX:

  bedingung ? expression1 : expression2 ;

  Wert des Ausdrucks: Entweder der Wert von expression1 oder expression2,
  je nach dem Wert der 'bedingung':
  true => expression1
  false => expression2

  Beispiel:

      x = (a > b) ? 10 : 20;

      if (a > b) {
          x = 10;
      }
      else {
          x = 20;
      }


    ODER:  
    
    return (a > b) ? 10 : 20;

============================================

Feld // Array

Vergleich:

C# / Java:     int[] zahlen = new 

C:
 
 Ein Feld hat eine FESTE GRÖSSE !!!!!!! Durch einen KONSTANTEN Wert festgelegt werden.

 Bemerkung:

 Für Variablen, die NICHT vorbelegt sind,
 wird ein spezielles Muster in den Speicher geschrieben:
 0xCC == Visual C++

 Vorsicht !!!!!!!!!!!!!!!!!

Falsche Indices für Felder in C werden NICHT zur Laufzeit
überprüft !!!!!!!!!!!!!!!

Wie läuft das Programm dann ab:

UB:  Undefined Behaviour

== Es läuft - wir erkennen keine Fehler 
== Es stürzt ab
== Sporadische Feher / Abstürze

In C#/ Java wird ein Programm im Kontext einer virtuellen Maschine ausgeführt.
(JVM, CLR) ==> Hier werden Indices kontrolliert ==> Abbruch 
Kontrolliert // Exception // könnte man fangen (try .. catch)

============================================================

Es gibt Anweisungen der Gestalt

#define Max 5

Die ist eine Preprocessor-Anweisung (Präprozessor):

Was ist der Präprozessor:

Tool, welches eine Textersetzung / Textaustausch vornimmt:

Jedes Vorkommen von Max ==> 5

Ausnahmen:  "Maximum"

Auch 

#include <stdio.h>

ist eine Präprozessor-Anweisung.

Hinweis: 

Der Gebrauch des Präprozessor ist nicht unbedingt Best-Practice:

#define Max 5

Hier laufern Gefahren !!!!!!!!!!!!!!!!!!!!!!!!!!!


==========================================================

Quelltext 
   ==> Präprozessor 
   ==> Compiler (.obj) 
   ==> (.obj) Linker 
   ==> (.exe) Maschinencode.

==========================================================

Zusammenfassung:

Felder in C:

Fixed-Size !!!

Keine Überprüfung des Index zur Laufzeit !!!

Längenangabe: 

Kann mit #define erfolgen:  // Präprozessor-Anweisung.

Vorsicht bei  Präprozessor-Anweisungen: 

Die Textersetzung wird "wörtlich" genommen.

==========================================================

Struktur eines C-Programms:

== Ein oder mehrere C-Dateien.  // Endung .c

== Ein oder mehrere Header-Dateien.  // Endung .h

   Für zB globale Funktionen

== Es gibt auch Funktionen, die in anderen Dateien NICHT verfügbar sein sollen
   -- Hilfsfunktionen
   -- Keyword 'static'

==========================================================

Datentyp char // Zeichen:

Syntax:  Einzelhochkomma für Zeichen !

Ausnahmen:  '\n' (13)  '\r'   (10)


Ein char steht für EIN einzelnes Zeichen!

Wie wird ein Zeichen im Speicher abgelegt ?

Binäre Darstellung eines Zeichens ???

ASCII-Tabelle:  

Abbildung von Zeichen auf numerische Werte.

Bebachtung:

Dualität zwischen char und int.

=================================================

Beobachtung:

Wie ist \n definiert.

Unter Windows sind das 2 Zeichen:

0D  0A  // 13 10

Linux uses a single LineFeed character:

'\n'  0x0A  10

History:

So in ASCII, we really still only have Carriage Return \r which is 0x0d (Decimal 13),
and Line Feed \n, which is 0x0a (Decimal 10).


=============================================================

Zeichenketten:

Syntax:  Doppelhochkomma für Zeichenketten !

"12345"

Binäre Darstellung:

Gemäß den ASCII - Werten:

49 50 51 52 53 0

Problem: Wo steht die Länge einer Zeichenkette ???

a) Nirgends !!!
b) Die terminierende Null

Kleine Fragen:

Wie lang ist die Zeichenkette "12345" ???

i) 5

ii) Gegenfrage: Allgemein oder bzgl. der Ablage im Speicher.

    Ablage im Speicher:  6 Zeichen !!!!

Zweite Frage:

Von welchem Datentyp ist eine Zeichenkette in C ???

"12345"

a) const char* cp;    

b) Feld von Zeichen: char []

Dualität zwischen Feldern des Typs char und Zeichenketten.

======================================================

Zwischen Arrays und Pointern in C gibt es einen DIREKTEN Zusammenhang:

int numbers[10];

Der Bezeichner 'numbers' steht für die ANFANGSADRESSE des Arrays im Speicher.

======================================================

Nebenbei:

C ist in C++ "echt" enthalten - zu 99%.

Ein Beispiel: char* cp = "234"; geht NICHT in C++

Wahrheit: Auch nicht in C - Absturz.

Frage: Wo liegt eine Zeichenkette wir "123" im Speicher ??????????????

Speicherbereiche:

Datenspeicher 

Konkreter: Es kann das Code-Segment sein. Speicher für den Maschinencode.

Historische Gründe

========================================================

Fazit:

Konstante Zeichenkette ("123") sind NICHT schreibbar !!!

Sie liegen in einem schreibgeschützten Datenbereich.

Abhilfe:

Eine Zeichenkette in einen schreibbaren Bereich legen:

ALLES außer einer konstante Zeichenkette :)

ZB ein Feld von Zeichen.

======================================================

Zwischen Arrays und Pointern in C gibt es einen DIREKTEN Zusammenhang:

int numbers[10];

Der Bezeichner 'numbers' steht für die ANFANGSADRESSE des Arrays im Speicher.

Wo spielt das eine Rolle:

Bei der Übergabe eines Felds an ein Unterprogramm.
--------------------------------------------------

Folgefrage:

Wieviele Elemente sind hinter einer Adresse (Anfangsadresse) vorhanden ???

===> Das weiß man nicht !!!

Konsequenz:

Wie wird ein Feld an ein Unterprogramm übergeben ??????

Antwort: Mit Anfangsadresse UND Längenangabe.

Ausnahme: Zeichenketten:

Da geht es ohne die Längenangabe, weil am Ende der Zeichenkette im Speicher
ein 0-Wert steht.


Achtung:

'printf' : format string '%s' requires an argument of type 'char *',
but variadic argument 1 has type 'int *'


=============================================================

Zeiger-Arithmetik:
-------------------

Man kann mit Zeigern - in einem gewissen Umfang - rechnen !!!

Beispiel:

int* feld;
int  i;

feld + i

Was ist feld + i für eine Adresse ??????????

Beispiel: 

In feld steht 0x1024 drin.

Was ist feld + 1 für eine Adresse ???

1. Vermutung: 0x1025 

ABER: Ein int belegt im Speicher 4 Bytes !!!!!

Deshalb bedeutet feld + 1, wenn feld eine int-Adresse ist,
einen neuen Wert von +4:

 0x1024 ==> 0x1028

 Realität: Der Index (also zB 1) wird mit der Anzahl Bytes eines int-Werts
           multipliziert-

===============================================

Zeiger-Arithmetik:
-------------------

2 Optionen:

Adresse + Offset

++ Adresse          ; 0x1024 ==> 0x1028, wenn die Adresse auf einen int-Wert zeigt

===============================================

Ein Vergleich:

        tmp = *(feld + i);   // Zeiger Arithmetik
00007FF69528352E  movsxd      rax,dword ptr [rbp+24h]  
00007FF695283532  mov         rcx,qword ptr [feld]  
00007FF695283539  mov         eax,dword ptr [rcx+rax*4]  
00007FF69528353C  mov         dword ptr [rbp+44h],eax  

        tmp = feld[i];         // mit Index-Notation 
00007FF69528353F  movsxd      rax,dword ptr [rbp+24h]  
00007FF695283543  mov         rcx,qword ptr [feld]  
00007FF69528354A  mov         eax,dword ptr [rcx+rax*4]  
00007FF69528354D  mov         dword ptr [rbp+44h],eax  

Ironische Bemerkung:

"C hat keine Arrays" - wegen der Zeiger-Arithmetik


===============================================

Zeichenkettenverarbeitung:
-------------------------

Benerkung:

warning C4716: 'str_length': must return a value

Aber wir erhalten nur eine Warnung :(((((


===============================================================

toUpper:

a) Wenn ch ist kein Buchstabe => in das Ergebnis übernehmen !!!  zB '?'

b) if (ch >= 'a' && ch <= 'z')

   Wie wird aus klein groß ???

   ch = ch - 32;


==============================================================

Übungen

static void str_toUpper (char* src);

static void str_reverse (char* src);

// Einfügen EINES Zeichen
int chr_insert  (const char* src, int pos, char ch, char* dest, int destLen);

// Einfügen EINER Zeichenkette
int  str_insert  (const char* src, int pos, char* toInsert, char* dest, int destLen);

==============================================================

Speicherbereiche eines C–Programms:

(( Kleine Unterschiede zu Java / C# ))

a) Globale Variablen.

i) Definition

In EINER Datei:

int g_globalValue = 123;

ii) Verwendung:

Setzt eine Bekanntmachung voraus:

extern int g_globalValue;

Lebensdauer: Für die gesamte Laufzeit eines Programms !!!

Bemerkung:

Man kann die Verfügbarkeit einer globalen Variablen einschränken:

a) nur in einer Datei 

b) nur in einem Unterprogramm  // Gegenstück zur Charakteristik einer lokalen Variablen

Moral:

"Scattering" von globalen Variablen zu vermeiden

Benutze static so viel wie möglich .....

----------------------------------------------------------

a) Lokale Variablen:

Vereinbarung:

In Funkionen // NUR in Funktionen:

Exakter:  In Blöcken


===========================================================

Bebachtung:

Ein Header-File ist nicht übersetzbar ?!?

Struktur eines C-Projekts halten:

Viele C Files ====> 

Pro C-File resutiert EIN .obj File

Header-Files enthalten Informationen, zB extern-Deklarationen,
aber zu einem Header-File wird KEIN .obj File erzeugt.


Frage:

void test_using_local_variabes()
{
    int n = 123;  // lebt bis zum Ende der Funktion
    printf("n: %d\n", n);

    {
        int m = 456;  // lebt bis zum Ende des  Blocks  // { }
        printf("m: %d\n",m);

        int n = 789; 
        printf("n: %d\n", n);
    }

}

Ist in C# nicht übersetzungsfähig !

In C ist das übersetzungsfähig !!!

Stilistisch fragwürdig !!!

Don't go for this feature.

================================================

Speicherbereiche:
----------------

i)   Global ==> Datensegment
ii)  Lokal ==> Stack
iii) Dynamisch ==> Heap  // Halde (kommt noch)

Strukturen

Dynamische Speicherverwaltung

================================================

Lokale Variablen:

Stehen in einem Unterprogramm (Block) zur Verfügung
Nach dem Verlassen des Unterprogramms sind sie weg.

Frage: Wie kann man so etwas datentechnisch realisieren ???

Antwort: Stapel // Stack 


Unterprogramm:

  int a; 
  int b;

  ==> 2. Unterprogramm:

      int x;
      int y;
      int z;

  <===

  a = 3;
  b = 4;

Bereich: "Stack" // Stack-Segment // Stapel

Register: Stack-Pointer

Unterprogramm-Aufrufs // Stack 

===> "Stack-Frame"

Die "Stack-Frame"s eines laufenden Programms werden im Fenster "Call Stack" visualisiert.

==========================================================

Intel CPU:

Klassisch: 4 zentrale Segmente 

Aktuell:   6 Segmente

Segment-Register 

===========================================================

Strukturen

// Java, C#:  Der Vorgänger von Klassen

Was ist eine Struktur?

Eine Zusammenfassung von mehreren Variablen (auch unterschiedlichen Datentyps)
in einem gemeinsamen Sprachkonstrukt:

Beispiel:

Uhrzeit:  Stunden, Minuten und Sekunden

9:54:30 

int hours;
int minutes;
int seconds;

int hours1;
int minutes1;
int seconds1;

SYNTAX:

struct Name 
{
};


Alignment: Was ist das ???

Eine Festlegung, wo (elementare) Variablen im Speicher liegen 
in Bezug auf die Speicheradresse!

Beispiel:

int n;    // 0x1024

Frage: Könnte n auch an der Adresse 0x1025 liegen ?????

Prinzipiell ja:

Praxis:
Auf eine Variable // Speicherbereich mit mehreren Bytes
(int: 4 Bytes) wird über den Datenbus eine Adresse geschoben.

Eine CPU möchte diesen Zugriff PERFORMANT gestalten:
Damit das PERFORMANT geht, können / müssen in manchen Situationen
die Adressen VIELFACHE der GRÖSSE der Variablen sein.

Konkret:

Eine Variable wie n (int) kann liegen an

0x1024: Ja
0x1025: Nein
0x1026: Nein
0x1027: Nein
0x1028: Ja


Aber:

char vieleZeichen[4];

Hier liegen die Array-Variablen DICHT im Speicher.


Weitere Frage:

Welches Alignment hat eine Struktur:

Den Wert des größten Alignments in Bezug auf alle enthaltenen Variablen.


=================================================================

Strukturen an Funktionen übergeben:

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/ParameterPassingTechniques.md


Voreinstellung: Call-by-Value    ==> KOPIE

Benötigen:      Call-by-Address  ==> Adresse (==> Original)

==================================================================

static void printTime(Time time)
{
    printf("%02d:%02d:%02d\n", time.hours, time.minutes, time.seconds);
}

Hat so funktioniert :)

Belassen wir printTime so oder wechseln wir auch hier zur Übergabe einer Adresse ???

Wir sollten auch hier zu einer Adresse wechseln!

Was ist das Problem mit Kopien von Strukturvariablen ??? ==> Laufzeit , Performanz:

Beobachtung:

Strukturvariablen, die von einem UNTERPROGRAMM NICHT geändert werden sollten,
können bei Übergabe einer Adresse geändert werden.

Abhilfe:

Keyword const

=================================================================

Exkurs:

Objekt-Orientierung:

"Objekt-Orientierung in C für Arme". 

Wie könnte das aussehen:

== Beschreibung der Daten:

In einer Struktur (C++/C#/Java: Klasse)

== Beschreibung der Methoden:

C: Durch Funktionen, die die Struktur als ersten Parameter haben.

In C++/C#/Java:
Innerhalb der Klasse

== Vorbelegung von Strukturvariablen (C++/C#/Java: Objekt)

C: Mit einer Vorbelegungslistem
   zB

   Time now = { 10, 55, 0 };

C++/C#/Java: Konstruktoren

   Time now = new Time { 10, 55, 0 };   // C#/Java

== Destruktoren:

   Kommt noch.

====================================================

C kennt keinen Datentyp bool:

Konvention:

Man nehme int an Stelle von bool.

false: 0
true: ungleich 0

====================================================

Ein bool Ersatz für C

#include <stdbool.h>

====================================================

Übung Wallet:

Ein Tipp:

Ist mit 2 Variablen manchmal etwas lästig ...

Tipp:

Man nehme EINE Variable:  Da ist die Realisierung einfacher ....

unsigned int cents;

// Permanent von (Euro, Cent) ==> Cents runtergerechnet werden.

struct wallet
{
    unsigned long long m_euros;
    unsigned int       m_cents;
};

versus

// Lernen etwas dünne
struct wallet
{
    unsigned int m_cents;
};

========================================================

Bitweise Operationen bekannt / nicht bekannt

Ein Bit in einem int-Wert setzen / löschen

=======================================================

Ein Vergleich:

    struct Status1 status1;
    status1.heightValidated = 1;
00007FF68A516A3E  mov         dword ptr [rbp+0Ch],1     // BP = Base Pointer

    struct Status2 status2;
    status2.heightValidated = 1;
00007FF68A516A45  mov         eax,dword ptr [status2]  
00007FF68A516A48  or          eax,2  
00007FF68A516A4B  mov         dword ptr [status2],eax  

C und Bitfelder:

Pro:    Ermöglichen eine sehr KOMPAKTE Ablage von komprimierten Informationen (auf der Ebene von Bits)

Contra: Der resultierende Maschinencode ist aufwendiger)

Krux:   Performance versus Speicherbedarf.

=======================================================

Union:

Sehr ähnlich zu einer Struktur, ABER !!!!!!!!!!!!!!!

Alle Variablen der Union liegen
im Speicher ÜBEREINANDER / an derselben Stelle.

Why ?????????????????????????????????????????

Beispiel wie RGB oder eine IP-Adresse veranschaulicht ....

===================================================== 

Enum:   ==> Pascal

==> Bessere Lesbarkeit

Go for Enum.

====================================================

Low-Level Programmierung
========================

Spezielle Operatoren für Bit-weise Verarbeitung.

& (Binäres Und)  , | (Binäres Oder)  , Exklusives Oder (^), Negation (~)

Schiebe-Operationen: << und >>

1. Beispiel:

              10110011
              11001101
Binäres UND:  10000001


2. Beispiel:

               10110001
               11001101
Binäres ODER:  11111101


3. Beispiel:

                  1011 0001
                  1100 1101
Exklusiver ODER:  0111 1100   == 7C


====================================  

Schieben:

0010'0011

Nach links um 2 Bits schieben:

1000'1100 

Es werden unten 2 Nullen reingezogen.


VORSICHT:

2. Beispiel:

short:  16 Bits:

1000 1010 1100 0011

Nach rechts um 2 Bits schieben:

??10 0010 1011 0000

2 Antworten:

a) signed short (short) ==> Es werden von oben 1 nachgezogen,
            wenn aktuell das oberste Bit eine 1 ist (weil die Zahl negativ ist)

            Andernfalls 0-en.

b) unsigned short 

   Es werden 0 nachgezogen.

==============================================

Ein Bit setzen:

=============>
             |
value: 11010101010101
mask:  00000010000000
=====
OR     11010111010101

Wie erhalten wir diese Maske ???

0000000000100

Mit 1 << pos;

Ein Bit löschen:

================>
                |
value: 11010101010101
mask:  11111111101111
=====
AND    11010111010101

Hinleitung:

00000010000000  ==> invertieren:
11111101111111

Binäre Not: Aus 0 mach 1, aus 1 mach 0

======================================================

Dynamischen Speicherverwaltung:

3 zentrale Speicherbereiche in C:

= glob. Daten
= lok. Daten
= dyn. Daten

Vergleich: Java, C#

1 (ggf. 2) zentrale Speicherbereiche:

= dyn. Daten
= lok. Daten - aber nur für Referenzen

Was ist der Nachteil von lok. Daten ???

=> Zwischenergebnisse

Habe nur eine kurze Lebensdauer.

// Man kann Adressen

Optimale: dyn. Daten

== Anforderung bei Befarf.
== Freigabe, wenn nicht mehr benötigt

Wie anfordern ???

Nicht in der Sprache definiert.
==> Bibliothek.

malloc  // memory allocate
free    // free

C++ Pendants:
new
delete

// ======================================================

Typkonvertierungen:  Exlplizit ( mit Cast ) oder implizit (nix zu tun)

 
 
 '=': conversion from '__int64' to 'short', possible loss of data

 '=': conversion from 'double' to '__int64', (possible) loss of data

 Ähnlich:


  'initializing': truncation from 'double' (8) to 'float' (4)



 possible loss of data:

 Kentnisse: Unser Wert auf der rechten Seite PASST IN DIE LINKE SEITE !!!


// ======================================================

int  ==> ganze Zahlen, positive und negative

Es gibt Situtationen, wo keine negativen Werte in Erscheinung treten:

int s = sizeof (int);

// Puristen:

size_t s = sizeof (int);

unsigned long long == size_t


// ======================================================

Achtung: Jeder RESERVIERTE Speicher (malloc) muss mit free freigegeben werden.

Zu jedem malloc muss es ein free geben !!!!!!!!!!!!!!!!!!!!!

// ======================================================

malloc: Liefert einen Zeiger zurück auf den Heap.

Wenn kein Speicher vorhanden: NULL

Best-Practice:

    int* ptr = (int*) malloc(wieviel);

    if (ptr == NULL) {

Macht man das wirklich so ??????????

a) bei kleinen Anforderungen: Nein.

b)  int* ptr = (int*) malloc(100'000);

Bei der Verarbeitung großer Datenmengen: JA.

======================================================

Was ist das Problem der dynamischen Speicherverwaltung ?

===> Wer ruft free auf ??? !!!!!!!!!!!!!!!!!!!!!!!

So dass kein Speicher am Ende verloren geht !!!

------------------------------------------------------

Was passiert, wenn 2 Mal free aufgerufen wird???

Es schadet ja nichts, wenn 2 Mal freigegeben wird :)   "double free"  // "double delete"

Katastrophe: Im Speicher auf der Halde sind neben den freien Blöcken für die Anwenung
             auch Verwaltungsinformationen der so gen. Freispeicher-Liste vorhanden.

https://github.com/pelocpp/cpp_clean_performant_secure/blob/master/Clean_Performant_Code/Performance_Optimization_Advanced/Readme_Performance_Optimization_Advanced_Fixed_Size_Block_Memory_Manager.md


========================================================

Java, C#:

Time t = new Time();

delete: Java, C#:  ===> Gibt es nicht: Diese Sprachen räumen selbständig auf.

                   Garbage Collection

Beobachtung:

C++:

Time* t = new Time();
delete t;

C:

Time* t = (Time*) malloc(sizeof (Time));
free(t);


C/C++: Hohe Performanz:

Java/C#:  Indirektion über eine virtuelle Maschine.

=====================================

Dyn. Speicherverwaltung:

Umsetzung / Vertiefung an Hand einer Übung.

Feld variabler Länge: Strukturierte Lösung.

Struktur:

Idee:

// -----------------------------------
// types

struct DynamicIntArray
{
    int*    m_data;  // Anfangsadresse
    size_t  m_count; // Länge des Felds  // immer groesser Null
};

// -----------------------------------
// function prototypes


// API:  Application Programming Interface

// Struktur DynamicIntArray: Programming Interface einer Struktur



int initDynamicIntArray(struct DynamicIntArray* array, size_t length);  // malloc
void releaseDynamicIntArray(struct DynamicIntArray* array);             // free

void fillDynamicIntArray(struct DynamicIntArray* array, int value);

size_t getLength(struct DynamicIntArray* array);
int get(struct DynamicIntArray* array, int index);
void set(struct DynamicIntArray* array, int index, int value);

int minimum(struct DynamicIntArray* array);
int maximum(struct DynamicIntArray* array); 

int indexOf(struct DynamicIntArray* array, int value);

int equalsDynamicIntArray(struct DynamicIntArray* array, struct DynamicIntArray* other);

int containsDynamicIntArray(struct DynamicIntArray* array, int value);

void printDynamicIntArray(struct DynamicIntArray* array);

// ========

int resizeDynamicIntArray(struct DynamicIntArray* array, int newLength);
int shrinkToFitDynamicIntArray(struct DynamicIntArray* array);


// -----------------------------------
// function prototypes

void main()
{
    struct DynamicIntArray array = { NULL, 0 };   // leeres Feld

    initDynamicIntArray (&array, 10);

    // array.m_data[99]

    releaseDynamicIntArray(&array);
}

https://github.com/pelocpp/c_introduction/blob/master/C_Introduction/Exercises/DynamicIntArray/Exercises_DynamicIntArray.md


===========================================================

Bemerkung:

malloc:  Reserviert Speicher, OHNE diesen auf 0 vorzubelegen.

calloc:  Reserviert Speicher und belegt diesen auf 0 vor.

Performanz:

void *malloc(
   size_t count,  // Anzahl in Bytes // 

);

void *calloc(
   size_t number,  // Anzahl der Element
   size_t size     // sizeof (int)
);

// ==========================================================================

Möchte ich die Länge des Arrays verändern können ???

// ==========================================================================

Nebenbei Frage:

C++   ==> DynamicIntArray

Java: ArrayList : Yessssssssssssssss

Python Liste

C++:  STL:    std::vector

C++/Java/C#:  Allgemeiner:  std::vector<T>

In C hat man KEINE Möglichkeit, Datentypen (wie in Java, C++ ... ) auszutauschen, generisch zu halten.

// ==========================================================================


Letzte Anmerkung:

In Sprachen wie  Java, C++ und C# kann man Objekte KOPIEREN:

VORSICHTIG:

Java / C#:

Time t1 = new Time(...);
Time t2 = new Time(...);

t1 = t2;    // 1. Frage: Ist t2 eine Kopie von t1: NEIN, es wird nur eine Referenz umgesetzt

t1 = t2.clone();    // 2 Frage: Könnte man eine Kopie irgendwie anders bekommen ???

C:  

Time soll dabei eine Struktur sein.

Time t1 = { 10, 30, 0 };
Time t2 = { 12, 30, 0 };

t1 = t2;

Auch hierzu eine Frage:

struct dynamicIntArray
{
    int*    m_data;
    size_t  m_length;
};

struct dynamicIntArray array1;
struct dynamicIntArray array2;

array1 = array2;  // Sehen wir da ein Problem ????????????????????

A) VORSICHT - NICHT TUN :-)))))))))

Yes: Da ist eine Adresse mit drin ... hierdurch entstehen Probleme !!!!

B) Kopier-Konstruktor // Copy-Constructor

Nachahmung des Kopier-Konstruktors im Stile von C++

releaseDynamicIntArray (& array1);

releaseDynamicIntArray (& array2);

Können wir dieses Problem in C lösen:

Wir könnten den Copy-Constructor nachstellen / imitieren :)

void  createDynamicIntArrayFromDynamicIntArray (DynamicIntArray* array, DynamicIntArray* other)

================================================================

Bemerkung:

    if (array->m_data == (int*) 0) {   // mir gefällt das besser:  LESBARKEIT

    if (array->m_data == NULL) {

================================================================

2. Übung:
=========

Was ist die Kernzone von C++:   "Zeiger und dynmische Daten".


Wir betrachten folgenden C-Funktionsprototyp:


// Beispiel:

// An "12345" soll "ABC" angehängt werden: "12345ABC"

void str_append (const char* original, const char* toAppend);

Lösung vom Mittwoch:

// hier musste man ein char-Array übergeben: char* dest, int destLen
// Wie lange soll denn dieses Array sein ???????????????
// Problematisch
static int str_append(const char* src, const char* toAppend, char* dest, int destLen);


A) 1. Versuch:

char* str_append (const char* original, const char* toAppend);

Hier wird eine Adresse zurückgegeben: via malloc gebildet werden.

char* result = str_append ("12345", "ABC");

Pro:     Der Speicherbedarf für das Ergebnis kann EXAKT gebildet / berechnet werden.

Contra:  Der Ergebniszeiger (hier: result) MUSS an free gereicht werden,
         wenn ich das Ergebnis nicht mehr benötige !!!!!!!!!!!!!!!!!

A) 2. Versuch:

char* result = NULL;   // <=== Ergebnis von str_append soll hier reingeschrieben werden

int str_append (const char* original, const char* toAppend, char** ergebnis);

Aufruf:

int success = str_append ("12345", "ABC", &result);


Rückgabewert 'int':

= 0: malloc ist fehlgeschlagen, kein Ergebnis

= 1: str_append hat funktioniert.

==========================================================


ptr: F95AE550
Done.

Detected memory leaks!
Dumping objects ->
C:\\Topic_13_Dynamic_Memory.c(123) : {82} normal block at 0x000001C6F95AE550, 20 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.

CC CC CC: Beim Array

Nicht vorbelegt // von Werten die am STACK liegen

Beim malloc:

CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD

Nicht vorbelegt // von Werten die am HEAP liegen

==============================================================

Zeichenketten: Gibt es denn da keine Unterstützung von einer  Bibliothek:

CRT:  C Runtime Library 

Abschnitt zu Zeichenketten:

===============================================

11 zum Ersten


strcat_s  ==> str_append

===============================================

Fading Out:

https://github.com/pelocpp/c_introduction/blob/master/C_Introduction/Exercises/ZeichenkettenverarbeitungDynamisch/ZeichenkettenverarbeitungDynamisch.md

int str_append(const char* original, const char* toAppend, char** result);

ODER

char* str_append(const char* original, const char* toAppend)

<string.h>

strlen (original);

strlen (toAppend);

Summe bilden dieser Wert -- Vorsicht: Kleinigkeit zu beachten ... 


malloc (von dieser berechneten Länge)

Länge: Exakt

Kopiert die beiden Zeichenketten original und toAppend um

und gebt die Adresse zurück.


===============================================================

Verkettete Liste // Linked List

Solltet ihr in Produkt-SW nicht selbst schreiben,
sondern aus einer Bibliothek // Github-Repo verwenden.

Siehe auch in den Aufgaben des Begleitmaterials.

===============================================================

Mehrdimensionale Arrays:

Genauer:

Feld von Feldern.

Wie wird ein mehr-dim Feld an ein Unterprogramm übergeben ???


===============================================================

Mehrdimensionale Arrays, deren einzelne Reihen unterschiedlich lang sind.

Jagged-Array:


Wo steht die Information der einzelnen Längen einer bestimmten Reihe:

Prinzipiell nirgends.

Lösung: Die Längenangaben müssen in einem zweiten Array aufgehoben werden.


Übung:

Erstellen Sie ein jagged Array.

Die i-te Zeile soll i Elemente enthalten.

In allen Elemente soll fortlaufend nummeriert werden:

1
1 2
1 2 3
1 2 3 4
1 2 3 4 5

Die Anzahl der Zeilen ist als Parameter an das Unterpramm zu übergeben.

Erstellen Sie zu diesem Zweck die folgenden Unterprogramme:

a) int** createJaggedArray();

b) void printJaggedArray(int** jaggedArray, int numRows);

c) void releaseJaggedArray(int** jaggedArray, int numRows);

===============================================================

CRT // Bibliothek
------------------

strcmp

Vergleich von Zeichenketten:   Lexikographischer Vergleich

Antwort:

kleiner:    < 0
gleich:     0
groesser:   > 0


===============================================================

Feld von Strukturen
-------------------


Beispiel:

Kontakteverwaltung bzw. Telefonbuch

Ein Kontakt:

Name, Nachname
Tel. Nr.
Adresse



Beispiel: Hans Mueller

Die Namen werden von der Konsole eingelesen.

==> Feld von Zeichen:

WIE LANGE ????  Das Feld dynamisch erstellen.

Lösung: 2 Schritten

A) Eingabe von der Konsole (App Tastatur):

char buffer [1000];   // da brauche ich ein FELD mit einer ausreichenden Länge

B) Die Länge berechnen, die eingegeben worden ist:

  strlen auf buffer angewendet.

C) Dynamisch ein Feld der Länge Len + 1 anlegen.

D) buffer umkopieren

E) Die Adresse in einer struct entry Variablen ablegen.

struct entry
{
    char*   m_firstName;
    // char    m_firstName [32];  // Das ist nicht elegant // ratsam
    char*   m_lastName;
    size_t  m_number;
};

Wie kann man viele derartige Einträge in einem Array ablegen:

struct entry entries[100];  // mehr wie 100 geht da mal nicht ...

// DynamicIntArray // DynamicEntryArray 

// ===========================================

Achtung:

Lokale Variablen werden (ohne Init.) NICHT vorbelegt.

Globale Variablen werden (ohne Init.) mit 0 // NULL vorbelegt.


Wie erkenne ich eine freie Stelle in dem globalen Array g_entries ???

1. Antwort: Dort, wo eine Tel.Nummer mit 0 vorhanden ist (0 ist keine gültige Nr.)

2. Antwort: Noch besser:

==============================================================================

1 Stunde:

a) Nachname fehlt.

b) Tel. Nummer fehlt

c) Print: Ausgabe aller vorhandenen Einträge (belegten)

d) Eine Nummer suchen:

  i) Auf der Konsole Vorname und Nachname eingeben.

  ii) Im Tel.Buch diese beiden namen suchen  (strcmp )

  iii) Wenn gefunden: *number = gefunden Wert rausschreiben.

  searchNumber (....., size_t* number)  // <=====

e) Das Tel.buch löschen:

  Für alle Vor- und Nachnamen free aufrufen.

===============================================================

